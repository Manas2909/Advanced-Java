/*
write a java pgm to connect to the mysql database and store static or fixed data into it which will always remain same for every pgm execution.



*/

package jdbc2.pack2;

import java.sql.*;

import java.io.*;

import java.util.Scanner;

public class Jdbc2
{

	void loadDriver1()throws ClassNotFoundException
	{
		Class.forName("com.mysql.jdbc.Driver");

	}

	void connect1()throws SQLException
	{
		Connection con=DriverManager.getConnection("jdbc:mysql://localhost:3306/database1",root","root");
		
		

		if(con!=null)
		{
		System.out.println("\n Connectivity is successfully established");
		Statement stmt=con.createStatement();
/*
Statement is a predefined interface of java.sql package and con.createStatement(), where createStatement() is a predefined non static member method of Connection interface, will return an implicit object of Statement interface which we are assigning to the stmt reference variable of the java.sql.Statement interface.

The main use of the Statement interface is to send static sql queries to the database. Static sql query is that query hose data always remains fixed because the data to be stored or updated using the static sql query is mentioned as fixed values in the static sql query itself. So everytime a static sql query is sent to the database the same data will be stored into the database.



*/		
			try
			{
				stmt.executeUpdate("create table employee1(eid int,ename varchar(100),esalary float)");
/*
executeUpdate() is a non static member method of java.sql.Statement interface and it is used to send static sql update queries( i.e. create query or insert query or update query or delete query) to the database where the static sql update query is passed as strng argument to stmt.executeUpdate().

so using the above stmt.executeUpdate(), we are sending the create static sql update query to the mysql sub database database1 which will create a new table employee1(if not existing already in mysql databse) with the 3 columns eid,ename and salary of types int,varchar(100) i.e. string of max. capacity 100 charactersany character capacity can be mentioned in the create query) and float types resp.

suppose the employee1 table was already exisiting in mysql database, then an exceptio wpuld be generated and so we have mentioned the stmt.executeUpdate() in a try block and mentioned a corresponding catch block to catch or store the exception generated by the stmt.executeUpdate() in the try block suppose the table named employee1 is already exisiting in mysql database.


*/
				stmt.executeUpdate("insert into employee1 values(1,'manas kumar',50000)");

/*
the above statement is sending an sql insert static query to the employee1 table which will insert 1 new row into the employee1 table with values 1,'manas kumar' and 50000 into the columns eid,ename and esalary resp. The new row will be inserted automatically after all exisiting rows of the employee1 table.

The above insert query is a static insert query because the values to be stored into the columns of the new row of the employee1 table have been mentioned in the query itself.


*/

				stmt.executeUpdate("insert into employee1 values(3,'mno pqr',60000)");

				stmt.executeUpdate("insert into employee1 values(3,'abc def',70000)");


				ResultSet rs=stmt.executeQuery("select * from employee1");
/*
ResultSet is a predefined interface of the java.sql package and it is used to access the data in the rows of the corresponding table in the database. executeQuery() is a predefined non static member method of java.sql.Statement interface and we have passed the sql select query as string argument to stmt.executeQuery().

stmt.executeQuery("select * from employee1") will first create a buffer memory in RAM memory and retrieve all rows of the employee1 table into the buffer memory and return an implicit object of java.sql.ResultSet interface which points before the 1st row of the employee1 table in the buffer memory.



*/

			System.out.println("\n The current employees stored in table are ");

			while(rs.next())
			{
				System.out.println("\n\n Employee Id:"+rs.getInt(1)+"    Employee Name:"+rs.getString(2)+"    Employee Salary:"+rs.getFloat(3));

			}
/*
next() is a predefined non static member method of java.sql.ResultSet interface and rs.next() will first check if there are any more rows in the table remaining to be accessed by the ResultSet object rs. Suppose there are more rows remaining to be accessed by ResultSet interface object, then rs.next() will return true and will automatically move the rs object to next row in the table.

getInt(),getFloat(),getString() etc. are the predefined non stati member methods of the ResultSet interface. So rs.getInt(1), rs.getString(2) and rs.getFloat(3) will retreive the integer, string and float values from the 1st, 2nd and 3rd columns resp. of employee1 table where the column nos have been passed as argument to rs.getInt(), rs.getString() and rs.getFloat() resp.

NOTE:
The data type of the column whose column number has been passed as argument to rs.get...() method must be exactly same as the data type name mentioned in the corresponding rs.get...() method else we get a runtime i.e. unchecked exception.



*/		
				con.close();
//closes connection with database
			}


			catch(Exception e)
			{
				e.printStackTrace();

			}


		}
		else
		System.out.println("\n Connectivity is not successfully established");

	}

	public static void main(String args[])throws SQLException,ClassNotFoundException
	{
		Jdbc2 j1=new Jdbc2();
		j1.loadDriver1();
		j1.connect1();		

	}
}
